Adding CybOX Objects
====================

The STIX/CybOX authoring interface contains reusable
templates for CybOX objects in the folder 
``mantis_authoring/cybox_object_transformers``. To
add a new template, follow the instructions below.


Create new template file
------------------------

Let us assume you are the author of the rather simple address object template.
Pick a descriptive name for your code file, e.g., ``address.py``, put
it into ``mantis_authoring/cybox_object_transformers`` and fill it with
the following boiler-plate code::
      

      from django import forms

      from .__object_base__ import transformer_object, ObjectFormTemplate
            
      # The name of a class defining a CybOx object template *MUST* have
      # the form 'TEMPLATE_<variant>'.
      
      class TEMPLATE_Default(transformer_object):
      
          # The fact_terms provided in  ``relevant_fact_term_list`` are
          # used for searching for similar objects that are presented to the
          # user upon request.
      
          relevant_fact_term_list = []
      
          # Display name of the object shown in the authoring interface
      
          display_name = 'IP Address'
      

          # Django form object with fields for relevant facts

          class ObjectForm(ObjectFormTemplate):
	      pass
      
      
          def process_form(self, properties,id_base=None,namespace_tag=None):
	      pass


Design template form
--------------------

Use the mechanisms Django provides you for defining formulars to design the
template form, e.g. as such::

        class ObjectForm(ObjectFormTemplate):

	    # The name of the field, here 'ip_addr' will occur in the JSON represenation of
            # the observable data generated by the authoring GUI

            ip_addr = forms.CharField(label="IP Address",
                                      required=True,
                                      help_text="REQUIRED. Be sure to enter data according to chosen format (v4 vs. v6. and"
                                                " single IP vs. network in slash notation)",
                                      max_length=100)
    
    
            CATEGORY_TYPES = (
                ('ipv4-addr', 'IPv4 Address'),
                ('ipv4-net', 'IPv4 Network (Slash notation)'),
                ('ipv6-addr', 'IPv6 Address'),
                ('ipv6-net', 'IPv6 Network (Slash notation)')
            )

	    category = forms.ChoiceField(choices=CATEGORY_TYPES, required=False, initial="ipv4-addr")


Please refer to the extensive Django documentation on form fields and browse the code
of existing CybOX object templates. Make use of the ``help_text`` feature to give
users guidance in how to fill in the fields.

    
Write transformer
-----------------

Each template requires a transformer function ``process_form`` that takes
the user input and uses the CybOX API from ``cybox.objects`` to
create a CybOx object (or CybOX 'Object Properties' object, to be precise).

Simple case: return a single object
...................................

Let us first look at a simple example the completes the example from above:: 

        from cybox.objects import address_object
        from cybox.common import String
    
        def process_form(self, properties,id_base=None,namespace_tag=None):

            # We use the cybox API to create an address object
            cybox_address = address_object.Address()

	    if properties['ip_addr'].strip():
	        # Actually, we have defined the field as required in the form
                # definition above, but the current version of the authoring interface
                # only warns and does not enforce that the form validates. So
                # to make sure that we have a value to enter, we check with
                # the if clause above.	  
                cybox_address.address_value = String(properties['ip_addr'].strip())

	    if properties['category'].strip():
                cybox_address.category = properties.get('category', None)

            # In this template, we only allow (and enforce) the 'Equals' condition

            cybox_address.condition = 'Equals'

            return cybox_address

    
Creating more than one object
.............................

There are cases in which we want to give the user the ability to generate several
objects from a single form, e.g. for entering a list of C&C domains, URLs or IPs
or for creating a main object with associated objects that are somehow
referenced by this object.

In that case, the main complication is that we need to generate identifiers
in the ``process_form`` function (notice that above, we did not deal with
an identifier at all). For this, the two additional arguments passed to
``process_form`` are used. ``process_form`` is called as follows:

     process_form(self, 
                  properties = <properties_dictionary>,
                  id_base= <a single uuid4 identifier>
                  namespace_tag= <identifier namespace to be used for the authored objects>)

Imagine a bulk object form that contains a single field ``data``, which contains
several return-separated URLs. It might call ``process_form`` as follows::

     process_form(self, 
                  properties = {'data': "evil.com\n malicious.com\n cybercrime.org"} 
                  id_base= 'dbf5f7bb-3bdf-343c-9af9-9ae5f7c38126',
                  namespace_tag= 'authoring_ns'
                 )

In order to have several objects created, ``process_form`` must return
the following dictionary::

               {'type': <'bulk' or 'obj_with_subobjects'>
                'main_obj_properties_instance': <main obj for type 'obj_with_subobjects', otherwise None>,
                'obj_properties_instances' : [(<derived_id_base_for_first_object>,<URI obj for 'evil.com'>),
                                              (<derived_id_base_for_second_object>,<URI obj for 'malicious.com'>),			      
                                              (<derived_id_base_for_third_object>,<URI obj for 'cybercrime.org')]
               }

The important thing here is to leave the creation of the derived id-base to the helper function
``create_derived_id`` that is available as ``self.create_derived_id``, since it is defined
in the ``transformer_object`` class. Call this function as follows::

               created_objects = []
               counter = 0
               for uri in <list of uris>:
                   obj = <create object from uri>
                   obj_id_base = self.create_derived_id(id_base,
                                                        fact = uri,
                                                        counter = counter)
                   counter += 1

		   created_object.append((obj_id_base,obj))


This will create identifiers based on the base uui4 identifier; depending on the mode for
generting identifiers that is defined in ``mantis_authoring.settings`` (but can be overwritten
by the Mantis settings), either the counter is used to augment the base uuid4 identifier
with a counter, or a hash value of "<base uuid4 identifier>-<fact>" is taken.

You can force a certain mode by passing the argument ``mode=<'hash' or 'counter'>``
to function ``create_derived_id``.

The difference between ``bulks`` and ``obj_with_subobjects``
............................................................

When creating bulk objects, **all** created objects will receive the object relations
as defined in the GUI for the single ``bulk object`` that is displayed in the GUI.
When creating a object with subobjects, the subobjects will not receive any
relations that are defined in the GUI: only the main object returned by the
``process_form`` function will be put in relation to other objects (if such
relations have been defined via the GUI).


How to reference subobjects during object creation
..................................................

When creating an object with sub objects, we usually need to refer
to the sub objects in the created main object in some way. For example
in an email object, we might want to create URI objects for existing
links and refer to them in the main email message object as such::

     <EmailMessageObj:Links>
        <EmailMessageObj:Link object_reference="cert_my_organization:URI-3834e86a-a963-c159-4542-e787894e205c-2505"/>
        <EmailMessageObj:Link object_reference="cert_my_organization:URI-3834e86a-a963-c159-4542-e787894e205c-2506"/>
     </EmailMessageObj:Links>

Here, ``3834e86a-a963-c159-4542-e787894e205c-2505`` and ``3834e86a-a963-c159-4542-e787894e205c-2506``
are the object base ids that have been generated by ``create_derived_id``. Given an object ``obj``,
use the function ``self.form_id_from_idbase`` as such::

     identifier = self.form_id_from_idbase(obj,
                                           namespace_tag,
                                           id_base)








    
      
      